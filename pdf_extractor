#=== SECTION 1: ASSEMBLIES ================================================

# === Load Required Assemblies ===
if (-not ("System.Windows.Forms.Form" -as [Type])) { 
    try {
        Add-Type -AssemblyName System.Windows.Forms -ErrorAction Stop
    }
    catch {
        $ErrorMessage = "‚ùå ERROR: Failed to load System.Windows.Forms. GUI elements may not work."
        Write-Host $ErrorMessage -ForegroundColor Red
        [System.Windows.Forms.MessageBox]::Show($ErrorMessage, "Critical Error", "OK", "Error")
    }
}

if (-not ("System.Drawing.Graphics" -as [Type])) { 
    try {
        Add-Type -AssemblyName System.Drawing -ErrorAction Stop
    }
    catch {
        $ErrorMessage = "‚ùå ERROR: Failed to load System.Drawing. Some graphical features may not work."
        Write-Host $ErrorMessage -ForegroundColor Red
        [System.Windows.Forms.MessageBox]::Show($ErrorMessage, "Critical Error", "OK", "Error")
    }
}

# === PowerShell Version Check ===
if ($PSVersionTable.PSVersion.Major -ge 7) {
    Write-Host "‚ö† WARNING: This script is designed for Windows PowerShell 5.1. Some features may not work in PowerShell Core 7.x or later." -ForegroundColor Yellow
    [System.Windows.Forms.MessageBox]::Show("This script is designed for Windows PowerShell 5.1. Some features may not work in PowerShell Core 7.x or later.", "Compatibility Warning", "OK", "Warning")
}

#=== SECTION 2: DIRECTORIES ===============================================

### === Define Directories Properly ===
$FallbackDir = "C:\PDF_Extractor"

try {
    $UserDocuments = [System.Environment]::GetFolderPath("MyDocuments")
    if ([string]::IsNullOrWhiteSpace($UserDocuments)) {
        throw "Unable to determine user 'Documents' folder."
    }
} catch {
    Write-Host "‚ö† Warning: Failed to fetch 'Documents' directory. Using fallback location: $FallbackDir"
    $UserDocuments = $FallbackDir
}

# Allow custom base directory from config.txt
$ProgramDir = Join-Path $UserDocuments "PDF_Extractor"
$MasterPDFDir = Join-Path $ProgramDir "Master_PDFs"
$ExportsDir = Join-Path $ProgramDir "Exports"
$LogDir = Join-Path $ProgramDir "Logs"

### === Load Custom Directory from config.txt (if available) ===
$ConfigPath = ".\config.txt"

if (Test-Path $ConfigPath) {
    try {
        # Read and parse config file
        $ConfigContent = Get-Content $ConfigPath | ConvertFrom-StringData
        $CustomPath = $ConfigContent["ProgramDir"].Trim()

        if (![string]::IsNullOrWhiteSpace($CustomPath) -and (Test-Path $CustomPath)) {
            $ProgramDir = $CustomPath
            $MasterPDFDir = Join-Path $ProgramDir "Master_PDFs"
            $ExportsDir = Join-Path $ProgramDir "Exports"
            $LogDir = Join-Path $ProgramDir "Logs"
            Write-Host "üìÇ Using custom Program Directory: $ProgramDir"
        } else {
            Write-Host "‚ö† Invalid or missing directory in config.txt. Resetting to default."
        }
    }
    catch {
        Write-Host "‚ùå Error reading config.txt: $_. Using default directories."
    }
}

### === Ensure all necessary directories exist ===
@($ProgramDir, $MasterPDFDir, $ExportsDir, $LogDir) | ForEach-Object {
    try {
        if (!(Test-Path $_)) { 
            if (-not (Test-Path (Split-Path $_))) {
                throw "Parent directory does not exist: $(Split-Path $_)"
            }
            New-Item -ItemType Directory -Path $_ -Force -ErrorAction Stop | Out-Null
            Write-Host "‚úÖ Created directory: $_"
        }
    }
    catch {
        Write-Host "‚ùå Error creating directory '$_': $($_.Exception.Message)"
    }
}

# === SECTION 3: BATCH INITIALIZATION =====================================================================

# === Introduce Global Batch Variable ===
$Global:LastBatchFolder = $null  # Stores the most recent batch folder

function Initialize-BatchFolder {
    # Generate timestamped batch folder
    $BatchTimestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $BatchFolder = Join-Path $ExportsDir $BatchTimestamp

    # Ensure the batch folder exists
    if (!(Test-Path $BatchFolder)) {
        try {
            New-Item -ItemType Directory -Path $BatchFolder -Force -ErrorAction Stop | Out-Null
            Write-Host "üìÇ Created batch folder: $BatchFolder"
        }
        catch {
            Write-Host "‚ùå Error creating batch folder: $_"
            return $null  # Return null if creation fails
        }
    }

    # Store batch folder globally
    $Global:LastBatchFolder = $BatchFolder
    return $BatchFolder
}

# Initialize batch folder at script startup
$Global:LastBatchFolder = Initialize-BatchFolder

# === SECTION 4: LOGGING SYSTEM ==========================================================================
# === Logging System Improvements ===
function Start-Logging {
    param ([string]$BatchTimestamp)

    # Ensure Log Directory Exists
    if (!(Test-Path $LogDir)) {
        New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
        Write-Host "‚úî Log directory created: $LogDir"
    }

    # Define batch log file name
    $LogFileName = "log_$BatchTimestamp.txt"
    $LogFilePath = Join-Path $LogDir $LogFileName
    $Global:CurrentLogFile = $LogFilePath  # Store for global reference

    # Remove old logs if more than 10 exist (Auto-archiving feature)
    $ExistingLogs = Get-ChildItem -Path $LogDir -Filter "log_*.txt" | Sort-Object LastWriteTime -Descending
    if ($ExistingLogs.Count -gt 10) {
        $LogsToDelete = $ExistingLogs | Select-Object -Skip 10
        $LogsToDelete | ForEach-Object { Remove-Item $_.FullName -Force }
        Write-Host "üóë Old logs archived. Keeping only the last 10 logs."
    }

    # Start logging safely
    try {
        Start-Transcript -Path $LogFilePath -Append -ErrorAction Stop
        Write-Host "üìù Logging started for batch: $BatchTimestamp"
    }
    catch {
        Write-Host "‚ö† Warning: Failed to start transcript logging. Logging will continue in console."
    }
}

function Stop-Logging {
    try {
        Stop-Transcript -ErrorAction Stop
        Write-Host "üìÅ Log saved: $Global:CurrentLogFile"
    }
    catch {
        Write-Host "‚ö† Warning: Failed to stop transcript logging."
    }
}

function Log-Message {
    param (
        [string]$Message,
        [string]$Type = "INFO"  # Default log type is INFO
    )

    # Define timestamp format
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"

    # Format message based on type
    switch ($Type) {
        "INFO" { $FormattedMessage = "[$Timestamp] üü¢ INFO: $Message" }
        "WARNING" { $FormattedMessage = "[$Timestamp] üü° WARNING: $Message" }
        "ERROR" { $FormattedMessage = "[$Timestamp] üî¥ ERROR: $Message" }
        default { $FormattedMessage = "[$Timestamp] $Message" }
    }

    # Write to log file safely
    if ($Global:CurrentLogFile -and (Test-Path $Global:CurrentLogFile)) {
        try {
            Add-Content -Path $Global:CurrentLogFile -Value $FormattedMessage -ErrorAction Stop
        }
        catch {
            Write-Host "‚ö† Warning: Unable to write to log file. Logging to console instead."
            Write-Host $FormattedMessage
        }
    }
    else {
        Write-Host $FormattedMessage
    }
}

# === SECTION 5: OVERLAY SYSTEM ==================================================================================

# === Overlay System Improvements ===
function Show-Overlay {
    param (
        [int]$ProgressMax,
        [string]$BatchTimestamp
    )

    # Prevent duplicate overlays
    if ($Global:OverlayForm -ne $null -and !$Global:OverlayForm.IsDisposed) {
        Write-Host "‚ö† Overlay already active. Skipping new overlay creation."
        return
    }

    # Ensure previous overlay is fully closed
    if ($Global:OverlayForm -ne $null) {
        Close-Overlay
        Start-Sleep -Milliseconds 500  # Shorter delay for smoother UI updates
    }

    # Create full-screen overlay
    $Global:OverlayForm = New-Object System.Windows.Forms.Form
    $Global:OverlayForm.WindowState = "Maximized"
    $Global:OverlayForm.FormBorderStyle = "None"
    $Global:OverlayForm.BackColor = [System.Drawing.Color]::FromArgb(245, 245, 245)  # Soft gray Windows 11 theme
    $Global:OverlayForm.TopMost = $true
    $Global:OverlayForm.ShowInTaskbar = $false

    # Progress Label (Centered)
    $Global:LogLabel = New-Object System.Windows.Forms.Label
    $Global:LogLabel.ForeColor = "Black"
    $Global:LogLabel.Font = New-Object System.Drawing.Font("Segoe UI", 18, [System.Drawing.FontStyle]::Bold)  # Larger, modern font
    $Global:LogLabel.AutoSize = $true
    $Global:LogLabel.Text = "Processing Batch: $BatchTimestamp..."
    $Global:LogLabel.Location = New-Object System.Drawing.Point(500, 200)
    $Global:OverlayForm.Controls.Add($Global:LogLabel)

    # Progress Bar (Centered)
    $Global:ProgressBar = New-Object System.Windows.Forms.ProgressBar
    $Global:ProgressBar.Style = "Continuous"
    $Global:ProgressBar.Maximum = $ProgressMax
    $Global:ProgressBar.Location = New-Object System.Drawing.Point(300, 300)
    $Global:ProgressBar.Size = New-Object System.Drawing.Size(600, 30)  # Wider bar
    $Global:OverlayForm.Controls.Add($Global:ProgressBar)

    # Cancel Button (Centered)
    $Global:CancelButton = New-Object System.Windows.Forms.Button
    $Global:CancelButton.Text = "Cancel"
    $Global:CancelButton.Size = New-Object System.Drawing.Size(200, 50)
    $Global:CancelButton.Location = New-Object System.Drawing.Point(500, 400)
    $Global:CancelButton.BackColor = [System.Drawing.Color]::FromArgb(240, 80, 80)
    $Global:CancelButton.Font = New-Object System.Drawing.Font("Segoe UI", 14, [System.Drawing.FontStyle]::Bold)
    $Global:CancelButton.ForeColor = "White"

    # Cancel Action
    $Global:CancelButton.Add_Click({
        $Global:CancelPrint = $true
        Write-Host "‚ùå Process canceled by user."
        Log-Message "üî¥ Process canceled by user." -Type "ERROR"
        Close-Overlay
    })
    $Global:OverlayForm.Controls.Add($Global:CancelButton)

    # Show overlay
    $Global:OverlayForm.Show()
    Write-Host "üñ• Full-screen overlay displayed for batch: $BatchTimestamp."
}

# Function to update overlay progress and message dynamically
function Update-Overlay {
    param (
        [string]$Message,
        [int]$ProgressValue
    )

    if ($Global:OverlayForm -ne $null) {
        $Global:LogLabel.Text = $Message
        $Global:ProgressBar.Value = $ProgressValue
        $Global:OverlayForm.Refresh()
        [System.Windows.Forms.Application]::DoEvents()
        Log-Message "üîÑ Overlay Update: $Message (Progress: $ProgressValue)"
    }
}

# Function to close overlay safely
function Close-Overlay {
    if ($Global:OverlayForm -ne $null) {
        Write-Host "üõë Closing overlay..."
        Log-Message "üõë Closing overlay."

        $Global:OverlayForm.Invoke([Action] {
            $Global:LogLabel.Text = "Closing overlay..."
            Start-Sleep -Seconds 1  # Brief pause to display the message
            $Global:OverlayForm.Close()
        }) 

        $Global:OverlayForm.Dispose()
        $Global:OverlayForm = $null
        Write-Host "‚úî Overlay closed."
    }
}

# === SECTION 6: PRINT MECHANICS === 

# === Function to Retry Failed Exports (Fixed) ===
function Retry-FailedExports {
    param (
        [array]$FailedExports,
        [int]$MaxRetries = 3
    )

    if (-not $FailedExports -or $FailedExports.Count -eq 0) {
        Log-Message "‚úÖ No failed exports to retry. Skipping retry process."
        return
    }

    Write-Host "üîÑ Retrying failed exports..."
    $RetryCount = @{ }
    $BaseDelay = 2  # Start with 2-second delay between retries

    foreach ($FailedExport in $FailedExports) {
        if ($FailedExport.OutputName -and -not $RetryCount.ContainsKey($FailedExport.OutputName)) {
            $RetryCount[$FailedExport.OutputName] = 0
        }
    }

    # Ensure overlay is displayed
    if ($Global:OverlayForm -eq $null) { Show-Overlay -ProgressMax 5 }

    while ($FailedExports.Count -gt 0) {
        $NewFailedExports = @()

        foreach ($Export in $FailedExports) {
            if ([string]::IsNullOrWhiteSpace($Export.OutputName) -or [string]::IsNullOrWhiteSpace($Export.PageRanges)) {
                Log-Message "‚ö† Skipping empty row."
                continue
            }

            if (-not $Export.SaveDir -or -not $Export.OutputName) {
                Log-Message "‚ö† Skipping export due to missing SaveDir or OutputName."
                continue
            }

            # **Ensure Edge & print processes are fully closed before retrying**
            Close-AllEdgeProcesses
            Clear-PrintQueue
            Start-Sleep -Seconds 2  # Allow time for processes to terminate

            $OutputFilePath = Join-Path $Export.SaveDir "$($Export.OutputName).pdf"

            # **If the file already exists, remove from failed queue and continue**
            if (Test-Path $OutputFilePath) {
                Log-Message "‚úÖ Skipping re-export: File already exists: $OutputFilePath"
                continue
            }

            if ($Global:CancelPrint) {
                Log-Message "‚ùå Export retry process canceled by user." -Type "ERROR"
                Close-Overlay
                return
            }

            if ($RetryCount[$Export.OutputName] -lt $MaxRetries) {
                Log-Message "üîÑ Retrying export for: $($Export.OutputName)... Attempt: $($RetryCount[$Export.OutputName] + 1)"

                # **Detect & auto-correct errors in variables before retrying**
                $Export.PageRanges = Fix-PageRange $Export.PageRanges
                $Export.PDFPath = Find-CloseMatchPDF -MissingPDF $Export.PDFPath

                # **Retry print operation**
                $Result = Print-PDF -PDFPath $Export.PDFPath -PageRanges $Export.PageRanges -SaveDir $Export.SaveDir -OutputName $Export.OutputName
                
                # **Implement exponential backoff delay**
                $WaitTime = $BaseDelay * ($RetryCount[$Export.OutputName] + 1)
                Start-Sleep -Seconds $WaitTime  

                # **Check if retry was successful**
                if (($Result -eq $null) -and (Test-Path $OutputFilePath)) {
                    Log-Message "‚úÖ Successfully retried export: $($Export.OutputName)"
                } else {
                    $NewFailedExports += $Result
                    $RetryCount[$Export.OutputName]++
                    Log-Message "‚ö† Retry $($RetryCount[$Export.OutputName]) failed for: $($Export.OutputName)"
                }
            } else {
                Log-Message "‚ùå Max retries reached for: $($Export.OutputName). Adding to final failed list." -Type "ERROR"
                $NewFailedExports += $Export
            }
        }

        # **Only keep truly failed exports in the retry queue**
        $FailedExports = $NewFailedExports
    }

    Close-Overlay

    if ($FailedExports.Count -gt 0) {
        Log-Message "‚ö† The following files failed after $MaxRetries retries:"
        foreach ($Failed in $FailedExports) {
            Log-Message "   - $($Failed.OutputName) ($($Failed.PDFPath))" -Type "ERROR"
        }
    } else {
        Log-Message "‚úÖ All previously failed exports were successfully retried."
    }
}

function Close-AllEdgeProcesses {
    Write-Host "üõë Closing all Edge processes..."
    Get-Process -Name "msedge" -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue
}

function Clear-PrintQueue {
    Write-Host "üñ® Clearing stuck print jobs..."
    Get-Printer | ForEach-Object { Remove-Printer -Name $_.Name -ErrorAction SilentlyContinue }
}

function Print-PDF {
    param (
        [string]$PDFPath,
        [string]$PageRanges,
        [string]$SaveDir,
        [string]$OutputName
    )

    try {
        Show-Overlay -ProgressMax 5  # Show overlay

        # Step 1: Open PDF in Edge
        Update-Overlay -Message "Opening Edge with PDF..." -ProgressValue 1
        $EdgeProcess = Start-Process -FilePath "msedge.exe" -ArgumentList "`"$PDFPath`"" -PassThru
        Start-Sleep -Seconds 5  # Ensure PDF is fully loaded

        if ($Global:CancelPrint) { 
            Write-Host "‚ùå Print cancelled by user."
            Close-EdgeTab -PDFPath $PDFPath
            Close-Overlay
            return
        }

        # Step 2: Open Print Dialog
        Update-Overlay -Message "Opening Print Dialog..." -ProgressValue 2
        [System.Windows.Forms.SendKeys]::SendWait("^+p")
        Start-Sleep -Seconds 3

        if ($Global:CancelPrint) { 
            Write-Host "‚ùå Print cancelled by user."
            Close-EdgeTab -PDFPath $PDFPath
            Close-Overlay
            return
        }

        # Step 3: Select Page Range
        Update-Overlay -Message "Selecting Page Range..." -ProgressValue 3
        Start-Sleep -Milliseconds 500
        for ($i=0; $i -lt 4; $i++) {
            [System.Windows.Forms.SendKeys]::SendWait("{TAB}")
            Start-Sleep -Milliseconds 100
        }
        [System.Windows.Forms.SendKeys]::SendWait("$PageRanges")
        Start-Sleep -Milliseconds 100
        [System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
        Start-Sleep -Milliseconds 500

        if ($Global:CancelPrint) { 
            Write-Host "‚ùå Print cancelled by user."
            Close-EdgeTab -PDFPath $PDFPath
            Close-Overlay
            return
        }

        # Step 4: Set Save Directory (PASTE INSTEAD OF TYPING)
        Update-Overlay -Message "Selecting Save Directory..." -ProgressValue 4
        Set-Clipboard -Value $SaveDir  # Copy directory to clipboard

        for ($i=0; $i -lt 6; $i++) {
            [System.Windows.Forms.SendKeys]::SendWait("{TAB}")
            Start-Sleep -Milliseconds 100
        }

        [System.Windows.Forms.SendKeys]::SendWait("{ENTER}")  # Open file path selection
        Start-Sleep -Milliseconds 500
        [System.Windows.Forms.SendKeys]::SendWait("^v")  # Paste directory path
        Start-Sleep -Milliseconds 500
        [System.Windows.Forms.SendKeys]::SendWait("{ENTER}")  # Confirm directory
        Start-Sleep -Seconds 2

        if ($Global:CancelPrint) { 
            Write-Host "‚ùå Print cancelled by user."
            Close-EdgeTab -PDFPath $PDFPath
            Close-Overlay
            return
        }

        # Step 5: Enter Filename
        Update-Overlay -Message "Saving File..." -ProgressValue 5
        for ($i=0; $i -lt 6; $i++) {
            [System.Windows.Forms.SendKeys]::SendWait("{TAB}")
            Start-Sleep -Milliseconds 100
        }

        [System.Windows.Forms.SendKeys]::SendWait("$OutputName")
        Start-Sleep -Milliseconds 500
        for ($i=0; $i -lt 3; $i++) {
            [System.Windows.Forms.SendKeys]::SendWait("{TAB}")
            Start-Sleep -Milliseconds 100
        }

        [System.Windows.Forms.SendKeys]::SendWait("{ENTER}")
        Start-Sleep -Seconds 5  # Ensure file is being processed

        if ($Global:CancelPrint) { 
            Write-Host "‚ùå Print cancelled by user."
            Close-EdgeTab -PDFPath $PDFPath
            Close-Overlay
            return
        }

        # Step 6: Verify Output File
        Update-Overlay -Message "Verifying Output File..." -ProgressValue 5
        Start-Sleep -Seconds 2

        $OutputFilePath = Join-Path $SaveDir "$OutputName.pdf"
        $MaxWait = 10  # Max wait time for file to appear
        $WaitTime = 0

        while (!(Test-Path $OutputFilePath) -and $WaitTime -lt $MaxWait) {
            Start-Sleep -Seconds 1
            $WaitTime++
        }

        if (!(Test-Path $OutputFilePath)) {
            Write-Host "‚ùå Error: Output file was not found in $SaveDir after waiting $MaxWait seconds."
            Update-Overlay -Message "Error: File Not Found" -ProgressValue 0
            Start-Sleep -Seconds 3
            Close-EdgeTab -PDFPath $PDFPath
            Close-Overlay
            return @{ "PDFPath" = $PDFPath; "PageRanges" = $PageRanges; "SaveDir" = $SaveDir; "OutputName" = $OutputName }
        } else {
            Update-Overlay -Message "File Saved Successfully" -ProgressValue 5
            Write-Host "‚úÖ Print job completed successfully: $OutputFilePath"

            # ‚úÖ Ensure print completes before closing Edge tab
            Start-Sleep -Seconds 2  

            # ‚úÖ Close only the tab, not the entire browser
            Write-Host "üßπ Cleaning up..."
            Update-Overlay -Message "Cleaning up..." -ProgressValue 5
            Close-EdgeTab -PDFPath $PDFPath

            Close-Overlay
            return $null
        }

    } catch {
        Write-Host "‚ùå Unexpected error during printing: $_"
        Update-Overlay -Message "Error: $_" -ProgressValue 0
        Start-Sleep -Seconds 3
    } finally {
        Close-Overlay
    }
}

function Close-EdgeTab {
    param (
        [string]$PDFPath
    )

    # Get all Edge processes
    $EdgeProcesses = Get-Process -Name "msedge" -ErrorAction SilentlyContinue

    foreach ($Process in $EdgeProcesses) {
        $WindowTitle = (Get-Process -Id $Process.Id -ErrorAction SilentlyContinue | Select-Object -ExpandProperty MainWindowTitle)

        if ($WindowTitle -match [System.IO.Path]::GetFileNameWithoutExtension($PDFPath)) {
            Write-Host "üßπ Closing Edge tab: $WindowTitle"
            Stop-Process -Id $Process.Id -Force -ErrorAction SilentlyContinue
            return
        }
    }

    Write-Host "‚ö†Ô∏è No matching Edge tab found for $PDFPath"
}

# === SECTION 7:  GUI === #

# === GUI Form Setup (Modern Windows 11 Look) ===
$Form = New-Object System.Windows.Forms.Form
$Form.Text = "PDF Extractor"
$Form.Size = New-Object System.Drawing.Size(1300, 650)  # Adjusted to fit everything
$Form.StartPosition = "CenterScreen"
$Form.BackColor = [System.Drawing.Color]::FromArgb(245, 245, 245)  # Soft Gray Windows 11 Look
$Form.FormBorderStyle = "FixedDialog"  # Prevent resizing

# Use Windows 11 Font
$Font = New-Object System.Drawing.Font("Segoe UI", 10, [System.Drawing.FontStyle]::Regular)

# === DataGridView (Fixed Size & Centered) ===
$DataGridView = New-Object System.Windows.Forms.DataGridView
$DataGridView.Location = New-Object System.Drawing.Point(20, 20)  
$DataGridView.Size = New-Object System.Drawing.Size(1160, 450)  # Fixed size
$DataGridView.AutoSizeColumnsMode = "Fill"
$DataGridView.AllowUserToAddRows = $true
$DataGridView.BorderStyle = "None"
$DataGridView.BackgroundColor = [System.Drawing.Color]::WhiteSmoke
$DataGridView.Font = $Font

# Add DataGridView to the form
$Form.Controls.Add($DataGridView)

# === Adjust Button Layout (Proper Spacing & Centering) ===
$ButtonWidth = 170  
$ButtonHeight = 40  
$Spacing = 10  # Reduced spacing for better alignment
$TotalButtons = 7  # Includes "Clear Grid"
$TotalWidth = ($ButtonWidth * $TotalButtons) + ($Spacing * ($TotalButtons - 1))  
$StartX = [Math]::Max(20, ($Form.ClientSize.Width - $TotalWidth) / 2)  
$StartY = 520  # Positioned closer to the grid

function Create-RoundedButton($text, $x, $y, $clickEvent) {
    $Button = New-Object System.Windows.Forms.Button
    $Button.Text = $text
    $Button.Size = New-Object System.Drawing.Size($ButtonWidth, $ButtonHeight)
    $Button.Location = New-Object System.Drawing.Point($x, $y)
    $Button.BackColor = [System.Drawing.Color]::FromArgb(220, 220, 220)  
    $Button.FlatStyle = "Flat"
    $Button.FlatAppearance.BorderSize = 1
    $Button.Font = $Font
    $Button.Add_Click($clickEvent)
    return $Button
}

# === Create & Add Buttons with Corrected Spacing ===
$BtnUploadPDF = Create-RoundedButton "Upload PDF" $StartX $StartY {}
$Form.Controls.Add($BtnUploadPDF)

$BtnMassMasterPDFs = Create-RoundedButton "Mass Input Master PDFs" ($StartX + ($ButtonWidth + $Spacing) * 1) $StartY {}
$Form.Controls.Add($BtnMassMasterPDFs)

$BtnMassInput = Create-RoundedButton "Mass Input Output Name" ($StartX + ($ButtonWidth + $Spacing) * 2) $StartY {}
$Form.Controls.Add($BtnMassInput)

$BtnPageRange = Create-RoundedButton "Mass Input Page Range" ($StartX + ($ButtonWidth + $Spacing) * 3) $StartY {}
$Form.Controls.Add($BtnPageRange)

$BtnStart = Create-RoundedButton "Start" ($StartX + ($ButtonWidth + $Spacing) * 4) $StartY {}
$Form.Controls.Add($BtnStart)

$BtnRetry = Create-RoundedButton "Retry Failed" ($StartX + ($ButtonWidth + $Spacing) * 5) $StartY {}
$Form.Controls.Add($BtnRetry)

# === Clear Grid Button (Final Button) ===
$BtnClearGrid = Create-RoundedButton "Clear Grid" ($StartX + ($ButtonWidth + $Spacing) * 6) $StartY {
    $Confirm = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to clear all data?", "Clear Grid", "YesNo", "Warning")

    if ($Confirm -eq "Yes") {
        $DataTable.Clear()  
        Write-Host "üîÑ Grid cleared successfully."
    }
}
$Form.Controls.Add($BtnClearGrid)

# === Create DataTable (Remove Dropdown, Keep Text Input for Master PDF) ===
$DataTable = New-Object System.Data.DataTable
$DataTable.Columns.Add("Master PDF", [string]) | Out-Null  
$DataTable.Columns.Add("Output Name") | Out-Null
$DataTable.Columns.Add("Page Range") | Out-Null
$DataGridView.DataSource = $DataTable

function Enable-AutoComplete {
    # Ensure the Master PDF directory exists
    if (!(Test-Path $MasterPDFDir)) {
        Write-Host "‚ö† Warning: Master PDF directory not found: $MasterPDFDir"
        return
    }

    # Get available PDF files
    $MasterPDFs = Get-ChildItem -Path $MasterPDFDir -Filter "*.pdf" | Select-Object -ExpandProperty Name

    # Ensure the list is not empty before calling .AddRange()
    if ($MasterPDFs.Count -eq 0) {
        Write-Host "‚ö† No PDFs found in $MasterPDFDir. Auto-complete will be empty."
        return
    }

    foreach ($Row in $DataGridView.Rows) {
        if ($Row.Cells["Master PDF"] -is [System.Windows.Forms.DataGridViewTextBoxCell]) {
            $AutoComplete = New-Object System.Windows.Forms.AutoCompleteStringCollection
            $AutoComplete.AddRange($MasterPDFs)  # üõ†Ô∏è Safe usage after checking for null/empty

            $TextBox = New-Object System.Windows.Forms.TextBox
            $TextBox.AutoCompleteMode = "SuggestAppend"
            $TextBox.AutoCompleteSource = "CustomSource"
            $TextBox.AutoCompleteCustomSource = $AutoComplete

            # Attach the textbox to the cell for auto-completion
            $Row.Cells["Master PDF"].Tag = $TextBox
        }
    }

    Write-Host "‚úÖ Auto-complete enabled with $($MasterPDFs.Count) PDFs."
}

# === SECTION 8: BUTTONS === 

# Call function on form load to populate suggestions
Enable-AutoComplete

# === CLEAR GRID BUTTON (Aligned & Styled) ===
$BtnClearGrid = Create-RoundedButton "Clear Grid" ($StartX + ($ButtonWidth + $Spacing) * 6) $StartY {
    $Confirm = [System.Windows.Forms.MessageBox]::Show("Are you sure you want to clear all data?", "Clear Grid", "YesNo", "Warning")

    if ($Confirm -eq "Yes") {
        $DataTable.Clear()  # Clears all rows but retains column headers
        Write-Host "üîÑ Grid cleared successfully."
    }
}

$Form.Controls.Add($BtnClearGrid)

# === Ensure Resizing Adjusts Grid Size ===
$Form.Add_Resize({
    $DataGridView.Size = New-Object System.Drawing.Size($Form.ClientSize.Width - 40, $StartY - 60)
})


# === Upload PDF Button Functionality ===
$BtnUploadPDF.Add_Click({
    $Dialog = New-Object System.Windows.Forms.OpenFileDialog
    $Dialog.Filter = "PDF Files (*.pdf)|*.pdf"
    if ($Dialog.ShowDialog() -eq "OK") {
        $FileName = [System.IO.Path]::GetFileName($Dialog.FileName)
        $DestPath = Join-Path $MasterPDFDir $FileName
        Copy-Item -Path $Dialog.FileName -Destination $DestPath -Force
        Refresh-PDFList
    }
})

# === Function: Refresh the Master PDF List in ComboBox ===
function Refresh-PDFList {
    try {
        # Ensure the directory exists
        if (!(Test-Path $MasterPDFDir)) {
            New-Item -ItemType Directory -Path $MasterPDFDir -Force | Out-Null
        }

        # Get all PDFs from the Master PDF directory
        $PDFs = Get-ChildItem -Path $MasterPDFDir -Filter "*.pdf" | Select-Object -ExpandProperty Name

        # Ensure the DataGridView ComboBox column exists
        if ($PDFColumn -ne $null) {
            $PDFColumn.Items.Clear()  # Clear old entries

            # Populate the ComboBox with available PDFs
            foreach ($PDF in $PDFs) {
                $PDFColumn.Items.Add($PDF) | Out-Null
            }

            Log-Message "üìÉ Master PDF list refreshed. Found $($PDFs.Count) PDFs."
        } else {
            Log-Message "‚ö† Warning: PDFColumn not found. Ensure the DataGridView ComboBox is properly initialized."
        }
    }
    catch {
        Log-Message "‚ùå Error refreshing PDF list: $_" -Type "ERROR"
    }
}

# === Mass Input for Master PDFs ===
$BtnMassMasterPDFs.Add_Click({
    $InputForm = New-Object System.Windows.Forms.Form
    $InputForm.Text = "Mass Input Master PDFs"
    $InputForm.Size = New-Object System.Drawing.Size(400, 300)
    $InputForm.StartPosition = "CenterScreen"
    $InputForm.TopMost = $true  # Keeps it on top

    # Multi-line TextBox
    $TextBox = New-Object System.Windows.Forms.TextBox
    $TextBox.Multiline = $true
    $TextBox.Size = New-Object System.Drawing.Size(350, 200)
    $TextBox.Location = New-Object System.Drawing.Point(20, 20)
    $InputForm.Controls.Add($TextBox)

    # OK Button
    $OkButton = New-Object System.Windows.Forms.Button
    $OkButton.Text = "OK"
    $OkButton.Location = New-Object System.Drawing.Point(150, 230)
    $OkButton.Size = New-Object System.Drawing.Size(80, 30)

    # Process Input
    $OkButton.Add_Click({
        $Entries = $TextBox.Text -split "`r`n"
        foreach ($MasterPDFValue in $Entries) {
            $MasterPDFValue = $MasterPDFValue.Trim()
            if (![string]::IsNullOrWhiteSpace($MasterPDFValue)) {
                $NewRow = $DataTable.NewRow()
                $NewRow["Master PDF"] = $MasterPDFValue
                $DataTable.Rows.Add($NewRow)
            }
        }
        Enable-AutoComplete  # Refresh auto-complete suggestions
        $InputForm.Close()
        $Form.Activate()  # Bring the main form back into focus
    })

    $InputForm.Controls.Add($OkButton)
    
    # Show as modal window (blocking the main form temporarily)
    $InputForm.ShowDialog()
})

# === Mass Input for Page Ranges ===
$BtnPageRange.Add_Click({
    $InputForm = New-Object System.Windows.Forms.Form
    $InputForm.Text = "Mass Input Page Ranges"
    $InputForm.Size = New-Object System.Drawing.Size(400, 300)
    $InputForm.StartPosition = "CenterScreen"
    $InputForm.TopMost = $true  

    # Multi-line TextBox
    $TextBox = New-Object System.Windows.Forms.TextBox
    $TextBox.Multiline = $true
    $TextBox.Size = New-Object System.Drawing.Size(350, 200)
    $TextBox.Location = New-Object System.Drawing.Point(20, 20)
    $InputForm.Controls.Add($TextBox)

    # OK Button
    $OkButton = New-Object System.Windows.Forms.Button
    $OkButton.Text = "OK"
    $OkButton.Location = New-Object System.Drawing.Point(150, 230)
    $OkButton.Size = New-Object System.Drawing.Size(80, 30)

    $OkButton.Add_Click({
        $Entries = $TextBox.Text -split "`r`n"
        for ($i = 0; $i -lt $Entries.Length; $i++) {
            $PageRangeValue = $Entries[$i].Trim()
            if (![string]::IsNullOrWhiteSpace($PageRangeValue)) {
                while ($i -ge $DataTable.Rows.Count) {
                    $DataTable.Rows.Add("", "", "")  
                }
                $DataTable.Rows[$i]["Page Range"] = $PageRangeValue
            }
        }
        $InputForm.Close()
        $Form.Activate()
    })

    $InputForm.Controls.Add($OkButton)
    $InputForm.ShowDialog()
})

# === Mass Input for Output Names ===
$BtnMassInput.Add_Click({
    $InputForm = New-Object System.Windows.Forms.Form
    $InputForm.Text = "Mass Input Output Names"
    $InputForm.Size = New-Object System.Drawing.Size(400, 300)
    $InputForm.StartPosition = "CenterScreen"
    $InputForm.TopMost = $true  

    # Multi-line TextBox
    $TextBox = New-Object System.Windows.Forms.TextBox
    $TextBox.Multiline = $true
    $TextBox.Size = New-Object System.Drawing.Size(350, 200)
    $TextBox.Location = New-Object System.Drawing.Point(20, 20)
    $InputForm.Controls.Add($TextBox)

    # OK Button
    $OkButton = New-Object System.Windows.Forms.Button
    $OkButton.Text = "OK"
    $OkButton.Location = New-Object System.Drawing.Point(150, 230)
    $OkButton.Size = New-Object System.Drawing.Size(80, 30)

    $OkButton.Add_Click({
        $Entries = $TextBox.Text -split "`r`n"
        for ($i = 0; $i -lt $Entries.Length; $i++) {
            $OutputNameValue = $Entries[$i].Trim()
            if (![string]::IsNullOrWhiteSpace($OutputNameValue)) {
                while ($i -ge $DataTable.Rows.Count) {
                    $DataTable.Rows.Add("", "", "")  
                }
                $DataTable.Rows[$i]["Output Name"] = $OutputNameValue
            }
        }
        $InputForm.Close()
        $Form.Activate()
    })

    $InputForm.Controls.Add($OkButton)
    $InputForm.ShowDialog()
})

# === Initialize GUI and Populate PDF List Before Displaying ===
Refresh-PDFList  # Call function to ensure the PDF list is preloaded

# === SECTION 9: START PROCESS =====================================================

function Validate-Inputs {
    $Global:ValidRows = 0
    $InvalidPDFs = @()
    $InvalidPageRanges = @()
    $DuplicateOutputNames = @()
    $OutputNameSet = @{}

    $TotalRows = $DataGridView.Rows.Count - 1
    for ($RowIndex = 0; $RowIndex -lt $TotalRows; $RowIndex++) {
        $Row = $DataGridView.Rows[$RowIndex]
        $PDFFileName = $Row.Cells["Master PDF"].Value
        $OutputName = $Row.Cells["Output Name"].Value
        $PageRanges = $Row.Cells["Page Range"].Value
        $PDFPath = Join-Path $MasterPDFDir $PDFFileName

        # Skip empty or transported rows
        if ([string]::IsNullOrWhiteSpace($PDFFileName) -and [string]::IsNullOrWhiteSpace($OutputName) -and [string]::IsNullOrWhiteSpace($PageRanges)) {
            continue
        }
        if ($Global:SkippedExports -contains "$OutputName.pdf") {
            Write-Host "‚ö† Skipping transported file: $OutputName.pdf"
            continue
        }

        $Global:ValidRows++

        # Run each validation function
        $PDFError = Validate-PDFExists -PDFPath $PDFPath -PDFFileName $PDFFileName -RowIndex $RowIndex
        if ($PDFError) { $InvalidPDFs += $PDFError }

        $PageRangeFormatError = Validate-PageRangeFormat -PageRanges $PageRanges -RowIndex $RowIndex
        if ($PageRangeFormatError) { $InvalidPageRanges += $PageRangeFormatError }

        $PageRangePDFError = Validate-PageRangeWithinPDF -PageRanges $PageRanges -PDFPath $PDFPath -RowIndex $RowIndex
        if ($PageRangePDFError) { $InvalidPageRanges += $PageRangePDFError }

        $DuplicateOutputError = Validate-DuplicateOutputNames -OutputName $OutputName -RowIndex $RowIndex -OutputNameSet $OutputNameSet
        if ($DuplicateOutputError) { $DuplicateOutputNames += $DuplicateOutputError }
    }

    # If errors exist, notify user and stop execution
    if ($InvalidPDFs.Count -gt 0 -or $InvalidPageRanges.Count -gt 0 -or $DuplicateOutputNames.Count -gt 0) {
        $ErrorMessage = "üö® Validation errors detected:`n`n"
        if ($InvalidPDFs.Count -gt 0) { $ErrorMessage += "‚ùå Missing PDFs:`n" + ($InvalidPDFs -join "`n") + "`n`n" }
        if ($InvalidPageRanges.Count -gt 0) { $ErrorMessage += "‚ö† Invalid Page Ranges:`n" + ($InvalidPageRanges -join "`n") + "`n`n" }
        if ($DuplicateOutputNames.Count -gt 0) { $ErrorMessage += "‚ùå Duplicate Output Names:`n" + ($DuplicateOutputNames -join "`n") + "`n`n" }

        [System.Windows.Forms.MessageBox]::Show($ErrorMessage, "Validation Errors", "OK", "Error")
        $Global:ValidRows = 0
    }
}

function Validate-PDFExists {
    param ([string]$PDFPath, [string]$PDFFileName, [int]$RowIndex)

    if (![string]::IsNullOrWhiteSpace($PDFFileName) -and !(Test-Path $PDFPath)) {
        Write-Host "‚ùå PDF not found: $PDFFileName (Row: ${RowIndex})"
        return "Row ${RowIndex}: ${PDFFileName}"
    }
    return $null
}

function Validate-PageRangeFormat {
    param ([string]$PageRanges, [int]$RowIndex)

    if (![string]::IsNullOrWhiteSpace($PageRanges) -and $PageRanges -match "\s") {
        Write-Host "‚ùå Invalid Page Range detected (Row ${RowIndex}): ${PageRanges}"
        return "Row ${RowIndex}: ${PageRanges}"
    }
    return $null
}

function Validate-PageRangeWithinPDF {
    param ([string]$PageRanges, [string]$PDFPath, [int]$RowIndex)

    if (![string]::IsNullOrWhiteSpace($PageRanges) -and (Test-Path $PDFPath)) {
        $ValidPageNumbers = Get-PDFPageCount -PDFPath $PDFPath
        $InvalidPages = @()

        # Split the input page ranges into an array
        $PageGroups = $PageRanges -split ","

        foreach ($Range in $PageGroups) {
            if ($Range -match "^\d+-\d+$") {  # Range format (e.g., 3-5)
                $Start, $End = $Range -split "-"
                for ($i = [int]$Start; $i -le [int]$End; $i++) {
                    if ($i -lt 1 -or $i -gt $ValidPageNumbers) {  # Page is out of bounds
                        $InvalidPages += $i
                    }
                }
            } elseif ($Range -match "^\d+$") {  # Single page (e.g., 7)
                if ([int]$Range -lt 1 -or [int]$Range -gt $ValidPageNumbers) {
                    $InvalidPages += [int]$Range
                }
            }
        }

        # If invalid pages exist, return error message
        if ($InvalidPages.Count -gt 0) {
            $ErrorMessage = "üö® Invalid page numbers detected!`n" +
                            "üìÑ PDF: ${PDFPath} (Total Pages: ${ValidPageNumbers})`n" +
                            "‚ùå Out-of-Range Pages in Row ${RowIndex}: " + ($InvalidPages -join ", ")

            [System.Windows.Forms.MessageBox]::Show(
                $ErrorMessage,
                "Page Range Error",
                "OK",
                "Error"
            )

            Write-Host $ErrorMessage
            return $false
        }
    }

    return $true
}

function Validate-DuplicateOutputNames {
    param ([string]$OutputName, [int]$RowIndex, [hashtable]$OutputNameSet)

    if (![string]::IsNullOrWhiteSpace($OutputName)) {
        if ($OutputNameSet.ContainsKey($OutputName)) {
            Write-Host "‚ùå Duplicate Output Name detected (Row ${RowIndex}): ${OutputName}"
            return "Row ${RowIndex}: ${OutputName}"
        } else {
            $OutputNameSet[$OutputName] = $true
        }
    }
    return $null
}

function Initialize-BatchFolder {
    # Generate timestamped batch folder
    $BatchTimestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $BatchFolder = Join-Path $ExportsDir $BatchTimestamp

    # Ensure the batch folder exists
    if (!(Test-Path $BatchFolder)) {
        try {
            New-Item -ItemType Directory -Path $BatchFolder -Force -ErrorAction Stop | Out-Null
            Write-Host "üìÇ Created batch folder: $BatchFolder"
        }
        catch {
            Write-Host "‚ùå Error creating batch folder: $_"
            return $null  # Return null if creation fails
        }
    }

    # Store batch folder globally
    $Global:LastBatchFolder = $BatchFolder
    return $BatchFolder
}

function Check-PreviousExports {
    param ([string]$BatchFolder)

    $PreviouslyExportedFiles = @{}
    $SkippedExports = @()

    # Get list of previous exports
    $PreviousExports = Get-ChildItem -Path $ExportsDir -Directory | Where-Object { $_.Name -ne (Split-Path -Leaf $BatchFolder) }
    foreach ($ExportFolder in $PreviousExports) {
        $ExportedFiles = Get-ChildItem -Path $ExportFolder.FullName -Filter "*.pdf"
        foreach ($File in $ExportedFiles) {
            $PreviouslyExportedFiles[$File.Name] = $File.FullName
        }
    }

    # If matching files exist, ask the user if they want to transport them
    if ($PreviouslyExportedFiles.Count -gt 0) {
        $TransportPrompt = [System.Windows.Forms.MessageBox]::Show(
            "Some files from previous exports match the ones you're trying to create.`n`nWould you like to transport them into the new folder instead of re-exporting?",
            "Transport Previously Exported Files",
            "YesNo", "Question"
        )

        if ($TransportPrompt -eq "Yes") {
            foreach ($FileName in $PreviouslyExportedFiles.Keys) {
                $NewPath = Join-Path $BatchFolder $FileName
                Copy-Item -Path $PreviouslyExportedFiles[$FileName] -Destination $NewPath -Force
                $SkippedExports += $FileName  # Mark as skipped
                Write-Host "‚úÖ Transported: $FileName ‚Üí $NewPath"
            }
        }
    }

    return $SkippedExports
}

function Start-ProcessLogging {
    param ([string]$BatchTimestamp)

    # Ensure Log Directory Exists
    if (!(Test-Path $LogDir)) {
        New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
        Write-Host "‚úî Log directory created: $LogDir"
    }

    # Define batch log file name
    $LogFileName = "log_$BatchTimestamp.txt"
    $LogFilePath = Join-Path $LogDir $LogFileName
    $Global:CurrentLogFile = $LogFilePath  # Store for global reference

    # Remove old logs if more than 10 exist
    $ExistingLogs = Get-ChildItem -Path $LogDir -Filter "log_*.txt" | Sort-Object LastWriteTime -Descending
    if ($ExistingLogs.Count -gt 10) {
        $LogsToDelete = $ExistingLogs | Select-Object -Skip 10
        $LogsToDelete | ForEach-Object { Remove-Item $_.FullName -Force }
        Write-Host "üóë Old logs archived. Keeping only the last 10 logs."
    }

    # Start logging safely
    try {
        Start-Transcript -Path $LogFilePath -Append -ErrorAction Stop
        Write-Host "üìù Logging started for batch: $BatchTimestamp"
    }
    catch {
        Write-Host "‚ö† Warning: Failed to start transcript logging. Logging will continue in console."
    }
}

function Display-ProcessingOverlay {
    param ([int]$ProgressMax, [string]$BatchTimestamp)

    # Prevent duplicate overlays
    if ($Global:OverlayForm -ne $null -and !$Global:OverlayForm.IsDisposed) {
        Write-Host "‚ö† Overlay already active. Skipping new overlay creation."
        return
    }

    # Ensure previous overlay is fully closed
    if ($Global:OverlayForm -ne $null) {
        Close-Overlay
        Start-Sleep -Milliseconds 500  # Shorter delay for smoother UI updates
    }

    # Create full-screen overlay
    $Global:OverlayForm = New-Object System.Windows.Forms.Form
    $Global:OverlayForm.WindowState = "Maximized"
    $Global:OverlayForm.FormBorderStyle = "None"
    $Global:OverlayForm.BackColor = [System.Drawing.Color]::FromArgb(245, 245, 245)
    $Global:OverlayForm.TopMost = $true
    $Global:OverlayForm.ShowInTaskbar = $false

    # Progress Label
    $Global:LogLabel = New-Object System.Windows.Forms.Label
    $Global:LogLabel.ForeColor = "Black"
    $Global:LogLabel.Font = New-Object System.Drawing.Font("Segoe UI", 18, [System.Drawing.FontStyle]::Bold)
    $Global:LogLabel.AutoSize = $true
    $Global:LogLabel.Text = "Processing Batch: $BatchTimestamp..."
    $Global:LogLabel.Location = New-Object System.Drawing.Point(500, 200)
    $Global:OverlayForm.Controls.Add($Global:LogLabel)

    # Progress Bar
    $Global:ProgressBar = New-Object System.Windows.Forms.ProgressBar
    $Global:ProgressBar.Style = "Continuous"
    $Global:ProgressBar.Maximum = $ProgressMax
    $Global:ProgressBar.Location = New-Object System.Drawing.Point(300, 300)
    $Global:ProgressBar.Size = New-Object System.Drawing.Size(600, 30)
    $Global:OverlayForm.Controls.Add($Global:ProgressBar)

    # Cancel Button
    $Global:CancelButton = New-Object System.Windows.Forms.Button
    $Global:CancelButton.Text = "Cancel"
    $Global:CancelButton.Size = New-Object System.Drawing.Size(200, 50)
    $Global:CancelButton.Location = New-Object System.Drawing.Point(500, 400)
    $Global:CancelButton.BackColor = [System.Drawing.Color]::FromArgb(240, 80, 80)
    $Global:CancelButton.Font = New-Object System.Drawing.Font("Segoe UI", 14, [System.Drawing.FontStyle]::Bold)
    $Global:CancelButton.ForeColor = "White"

    # Cancel Action
    $Global:CancelButton.Add_Click({
        $Global:CancelPrint = $true
        Write-Host "‚ùå Process canceled by user."
        Close-Overlay
    })
    $Global:OverlayForm.Controls.Add($Global:CancelButton)

    # Show overlay
    $Global:OverlayForm.Show()
    Write-Host "üñ• Full-screen overlay displayed for batch: $BatchTimestamp."
}

function Validate-ExportData {
    param (
        [System.Windows.Forms.DataGridView]$DataGridView,
        [array]$SkippedExports
    )

    $InvalidPDFs = @()
    $InvalidPageRanges = @()
    $DuplicateOutputNames = @()
    $OutputNameSet = @{}
    $ValidRows = 0
    $FixedPageRanges = @{}

    # Page range validation pattern
    $PageRangePattern = "^\d+(-\d+)?(,\d+(-\d+)?)*$"

    $TotalRows = $DataGridView.Rows.Count - 1
    for ($RowIndex = 0; $RowIndex -lt $TotalRows; $RowIndex++) {
        $Row = $DataGridView.Rows[$RowIndex]
        $PDFFileName = $Row.Cells["Master PDF"].Value
        $OutputName = $Row.Cells["Output Name"].Value
        $PageRanges = $Row.Cells["Page Range"].Value
        $PDFPath = Join-Path $MasterPDFDir $PDFFileName

        # Skip empty rows
        if ([string]::IsNullOrWhiteSpace($PDFFileName) -and
            [string]::IsNullOrWhiteSpace($OutputName) -and
            [string]::IsNullOrWhiteSpace($PageRanges)) {
            continue
        }

        # Skip transported files
        if ($SkippedExports -contains "$OutputName.pdf") {
            Write-Host "‚ö† Skipping transported file: $OutputName.pdf"
            continue
        }

        # Count valid rows
        $ValidRows++

        # Check if PDF file exists
        if (![string]::IsNullOrWhiteSpace($PDFFileName) -and !(Test-Path $PDFPath)) {
            Write-Host "‚ùå PDF not found: $PDFFileName"
            $InvalidPDFs += "$PDFFileName (Row: $($RowIndex + 1))"
        }

        # Detect spaces in Page Ranges
        if (![string]::IsNullOrWhiteSpace($PageRanges) -and $PageRanges -match "\s") {
            Write-Host "‚ùå Invalid Page Range detected (Row $RowIndex): $PageRanges"
            $InvalidPageRanges += "Row $($RowIndex + 1): $PageRanges"
            $FixedPageRanges[$RowIndex] = Format-PageRange $PageRanges
        }

        # Check if page range is valid in the actual PDF
        if (!(Test-PageRangeInPDF -PDFPath $PDFPath -PageRanges $PageRanges)) {
            Write-Host "‚ùå Invalid page range in actual PDF (Row $RowIndex): $PageRanges"
            $InvalidPageRanges += "Row $($RowIndex + 1): $PageRanges"
        }

        # Check for duplicate Output Names
        if (![string]::IsNullOrWhiteSpace($OutputName)) {
            if ($OutputNameSet.ContainsKey($OutputName)) {
                $DuplicateOutputNames += "Row $($RowIndex + 1): $OutputName"
            } else {
                $OutputNameSet[$OutputName] = $true
            }
        }
    }

    return @{
        "ValidRows" = $ValidRows
        "InvalidPDFs" = $InvalidPDFs
        "InvalidPageRanges" = $InvalidPageRanges
        "DuplicateOutputNames" = $DuplicateOutputNames
        "FixedPageRanges" = $FixedPageRanges
    }
}

function Handle-ValidationErrors {
    param (
        [hashtable]$ValidationResults,
        [System.Windows.Forms.DataGridView]$DataGridView
    )

    $ValidRows = $ValidationResults["ValidRows"]
    $InvalidPDFs = $ValidationResults["InvalidPDFs"]
    $InvalidPageRanges = $ValidationResults["InvalidPageRanges"]
    $DuplicateOutputNames = $ValidationResults["DuplicateOutputNames"]
    $FixedPageRanges = $ValidationResults["FixedPageRanges"]

    # Prevent start if there are no valid rows
    if ($ValidRows -eq 0) {
        [System.Windows.Forms.MessageBox]::Show(
            "üö® No valid rows found. Please enter at least one row before starting.",
            "Validation Error", "OK", "Error"
        )
        return $false  # Stop execution
    }

    # Compile error messages
    $ErrorMessage = ""
    if ($InvalidPDFs.Count -gt 0) {
        $ErrorMessage += "üö® The following PDFs are missing or invalid:`n" + ($InvalidPDFs -join "`n") + "`n`n"
    }
    if ($InvalidPageRanges.Count -gt 0) {
        $ErrorMessage += "‚ö† The following rows have invalid page ranges:`n" + ($InvalidPageRanges -join "`n") + "`n`n"
    }
    if ($DuplicateOutputNames.Count -gt 0) {
        $ErrorMessage += "‚ùå The following output names are duplicated:`n" + ($DuplicateOutputNames -join "`n") + "`n`n"
    }

    # If errors exist, prompt user
    if ($ErrorMessage -ne "") {
        [System.Windows.Forms.MessageBox]::Show(
            $ErrorMessage, "Validation Errors", "OK", "Error"
        )
        return $false  # Stop execution
    }

    # Auto-fix page ranges if necessary
    if ($FixedPageRanges.Count -gt 0) {
        $PromptMessage = "Would you like to automatically fix the following page ranges?`n" +
                         ($FixedPageRanges.Values -join "`n") + "`n`n" +
                         "This will remove spaces and apply correct formatting."

        $UserChoice = [System.Windows.Forms.MessageBox]::Show(
            $PromptMessage, "Auto-Fix Page Ranges", "YesNo", "Question"
        )

        if ($UserChoice -eq "Yes") {
            foreach ($RowIndex in $FixedPageRanges.Keys) {
                $Row = $DataGridView.Rows[$RowIndex]
                $Row.Cells["Page Range"].Value = $FixedPageRanges[$RowIndex]
            }
            Write-Host "‚úÖ Auto-fixed page ranges."
        } else {
            Write-Host "‚ùå User declined auto-fixing page ranges. **Execution will not proceed.**"
            return $false  # Stop execution if user doesn't allow fixes
        }
    }

    return $true  # Proceed with execution
}

function Process-Exports {
    param (
        [System.Windows.Forms.DataGridView]$DataGridView,
        [string]$BatchFolder,
        [array]$SkippedExports,
        [array]$FailedExports
    )

    # Initialize Progress Bar
    Show-Overlay -ProgressMax 5 -BatchTimestamp (Get-Date -Format "yyyyMMdd_HHmmss")

    $TotalRows = $DataGridView.Rows.Count - 1
    for ($RowIndex = 0; $RowIndex -lt $TotalRows; $RowIndex++) {
        $Row = $DataGridView.Rows[$RowIndex]
        $PDFFileName = $Row.Cells["Master PDF"].Value
        $OutputName = $Row.Cells["Output Name"].Value
        $PageRanges = $Row.Cells["Page Range"].Value
        $PDFPath = Join-Path $MasterPDFDir $PDFFileName
        $SaveDir = $BatchFolder
        $OutputFilePath = Join-Path $BatchFolder "$OutputName.pdf"

        # Skip empty or incomplete rows
        if ([string]::IsNullOrWhiteSpace($PDFFileName) -or
            [string]::IsNullOrWhiteSpace($OutputName) -or
            [string]::IsNullOrWhiteSpace($PageRanges)) {
            Write-Host "‚ö† Skipping empty or incomplete row: $($RowIndex + 1)"
            continue
        }

        # Skip transported files that were already moved
        if ($SkippedExports -contains "$OutputName.pdf") {
            Write-Host "üöÄ Skipping already transported file: $OutputName.pdf"
            continue
        }

        # Skip if output file already exists in current batch
        if (Test-Path $OutputFilePath) {
            Write-Host "‚úÖ Skipping existing file: $OutputFilePath"
            continue
        }

        # Print PDF
        $Result = Print-PDF -PDFPath $PDFPath -PageRanges $PageRanges -SaveDir $SaveDir -OutputName $OutputName

        if ($Result -ne $null) {
            $FailedExports += $Result  # Store failed attempts for retry
        }
    }

    # Close overlay after processing
    Close-Overlay

    return $FailedExports  # Return list of failed exports
}

function Retry-FailedExports {
    param (
        [array]$FailedExports,
        [int]$MaxRetries = 3
    )

    if (-not $FailedExports -or $FailedExports.Count -eq 0) {
        Write-Host "‚úÖ No failed exports to retry. Skipping retry process."
        return
    }

    Write-Host "üîÑ Retrying failed exports..."
    $RetryCount = @{}

    # Initialize Retry Counts
    foreach ($FailedExport in $FailedExports) {
        if ($FailedExport.OutputName -and -not $RetryCount.ContainsKey($FailedExport.OutputName)) {
            $RetryCount[$FailedExport.OutputName] = 0
        }
    }

    while ($FailedExports.Count -gt 0) {
        $NewFailedExports = @()

        foreach ($Export in $FailedExports) {
            $OutputFilePath = Join-Path $Export.SaveDir "$($Export.OutputName).pdf"

            # Skip if the file was successfully created in the meantime
            if (Test-Path $OutputFilePath) {
                Write-Host "‚úÖ Skipping re-export: File already exists: $OutputFilePath"
                continue
            }

            # Cancel process if user has aborted
            if ($Global:CancelPrint) {
                Write-Host "‚ùå Export retry process canceled by user."
                Close-Overlay
                return
            }

            # **Ensure Edge & Print processes are fully closed before retrying**
            Close-AllEdgeProcesses
            Clear-PrintQueue
            Start-Sleep -Seconds 2  # Allow time for processes to terminate

            # Check retry count before proceeding
            if ($RetryCount[$Export.OutputName] -lt $MaxRetries) {
                Write-Host "üîÑ Retrying export for: $($Export.OutputName)... Attempt: $($RetryCount[$Export.OutputName] + 1)"

                # **Detect & auto-correct errors before retrying**
                $Export.PageRanges = Fix-PageRange $Export.PageRanges
                $Export.PDFPath = Find-CloseMatchPDF -MissingPDF $Export.PDFPath

                # Retry print operation
                $Result = Print-PDF -PDFPath $Export.PDFPath -PageRanges $Export.PageRanges -SaveDir $Export.SaveDir -OutputName $Export.OutputName

                if (($Result -eq $null) -and (Test-Path $OutputFilePath)) {
                    Write-Host "‚úÖ Successfully retried export: $($Export.OutputName)"
                } else {
                    $NewFailedExports += $Result
                    $RetryCount[$Export.OutputName]++
                    Write-Host "‚ö† Retry $($RetryCount[$Export.OutputName]) failed for: $($Export.OutputName)"
                }
            } else {
                Write-Host "‚ùå Max retries reached for: $($Export.OutputName). Adding to final failed list."
                $NewFailedExports += $Export
            }
        }

        # Only keep truly failed exports in the retry queue
        $FailedExports = $NewFailedExports
    }

    if ($FailedExports.Count -gt 0) {
        Write-Host "‚ö† The following files failed after $MaxRetries retries:"
        foreach ($Failed in $FailedExports) {
            Write-Host "   - $($Failed.OutputName) ($($Failed.PDFPath))"
        }
    } else {
        Write-Host "‚úÖ All previously failed exports were successfully retried."
    }
}

function Move-ExportedFiles {
    param ([string]$BatchFolder)

    Write-Host "üîç Checking batch folder: $BatchFolder"

    if (!(Test-Path $BatchFolder)) {
        Write-Host "‚ùå Error: Batch folder not found: $BatchFolder"
        return
    }

    # List all PDF files that are not hidden/system files
    $ExportedFiles = Get-ChildItem -Path $BatchFolder -Filter "*.pdf" | Where-Object {
        -not $_.Attributes.HasFlag([System.IO.FileAttributes]::Hidden) -and 
        -not $_.Attributes.HasFlag([System.IO.FileAttributes]::System)
    }

    Write-Host "üìÑ Found $($ExportedFiles.Count) exported PDF files."

    if ($ExportedFiles.Count -eq 0) {
        Write-Host "‚ö† No exported files found. Exiting move process."
        return
    }

    # Open folder selection dialog
    Add-Type -AssemblyName System.Windows.Forms
    $FolderDialog = New-Object System.Windows.Forms.FolderBrowserDialog
    $FolderDialog.Description = "Select Destination Folder to Move Exported PDFs"
    $DialogResult = $FolderDialog.ShowDialog()

    if ($DialogResult -eq "OK") {
        $DestinationFolder = $FolderDialog.SelectedPath
        Write-Host "üìÇ Moving files to: $DestinationFolder"

        foreach ($File in $ExportedFiles) {
            $DestinationPath = Join-Path $DestinationFolder $File.Name

            # Check for overwrite conflicts
            if (Test-Path $DestinationPath) {
                Write-Host "‚ö† File already exists: $DestinationPath"
                $Response = [System.Windows.Forms.MessageBox]::Show(
                    "File $($File.Name) already exists. Overwrite?",
                    "File Exists", "YesNoCancel", "Warning"
                )

                if ($Response -eq "Yes") {
                    Move-Item -Path $File.FullName -Destination $DestinationPath -Force -ErrorAction Stop
                    Write-Host "‚úÖ Overwritten: $($File.Name)"
                } elseif ($Response -eq "No") {
                    $NewName = "$($File.BaseName)_Copy$($File.Extension)"
                    $NewDestinationPath = Join-Path $DestinationFolder $NewName
                    Move-Item -Path $File.FullName -Destination $NewDestinationPath -Force -ErrorAction Stop
                    Write-Host "‚úÖ Renamed and moved: $($File.Name) ‚Üí $NewDestinationPath"
                } else {
                    Write-Host "‚ö† Skipping file: $($File.Name)"
                    continue
                }
            } else {
                try {
                    Move-Item -Path $File.FullName -Destination $DestinationPath -Force -ErrorAction Stop
                    Write-Host "‚úÖ Moved: $($File.Name) ‚Üí $DestinationPath"
                }
                catch {
                    Write-Host "‚ùå Error moving $($File.Name): $_"
                }
            }
        }

        # Confirm success
        [System.Windows.Forms.MessageBox]::Show(
            "All exported PDFs have been successfully moved to:`n$DestinationFolder",
            "Move Completed", "OK", "Information"
        )
        Write-Host "‚úÖ All exported files successfully moved."
    } else {
        Write-Host "‚ö† User canceled file movement."
    }
}

$BtnStart.Add_Click({
    # Reset tracking variables
    $FailedExports = @()
    $SkippedExports = @()
    $ValidRows = 0

    # Generate batch timestamp and create export folder
    $BatchTimestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $BatchFolder = Initialize-BatchFolder -BatchTimestamp $BatchTimestamp

    if ($BatchFolder -eq $null) {
        return
    }

    # Check and transport previously exported files
    $SkippedExports = Check-PreviousExports -BatchFolder $BatchFolder

    # Validate all rows in the DataGridView
    $TotalRows = $DataGridView.Rows.Count - 1
    for ($RowIndex = 0; $RowIndex -lt $TotalRows; $RowIndex++) {
        $Row = $DataGridView.Rows[$RowIndex]
        $PDFFileName = $Row.Cells["Master PDF"].Value
        $OutputName = $Row.Cells["Output Name"].Value
        $PageRanges = $Row.Cells["Page Range"].Value
        $PDFPath = Join-Path $MasterPDFDir $PDFFileName

        # Skip empty rows
        if ([string]::IsNullOrWhiteSpace($PDFFileName) -and 
            [string]::IsNullOrWhiteSpace($OutputName) -and 
            [string]::IsNullOrWhiteSpace($PageRanges)) {
            continue
        }

        # Skip files that were already transported
        if ($SkippedExports -contains "$OutputName.pdf") {
            Write-Host "‚ö† Skipping transported file: $OutputName.pdf"
            continue
        }

        $ValidRows++

        # Perform validation checks
        if (-not (Validate-PDFExists -PDFFileName $PDFFileName -RowIndex $RowIndex) -or
            -not (Validate-DuplicateOutputNames -OutputName $OutputName -RowIndex $RowIndex -OutputNameSet $OutputNameSet) -or
            -not (Validate-PageRangeWithinPDF -PDFPath $PDFPath -PageRanges $PageRanges -RowIndex $RowIndex)) {
            
            [System.Windows.Forms.MessageBox]::Show(
                "Validation errors detected. Please fix the errors and restart.",
                "Validation Error", "OK", "Error"
            )
            return
        }
    }

    if ($ValidRows -eq 0) {
        [System.Windows.Forms.MessageBox]::Show(
            "üö® No valid rows found. Please enter at least one row before starting.",
            "Validation Error", "OK", "Error"
        )
        return
    }

    # Start logging and show processing overlay
    Start-Logging -BatchTimestamp $BatchTimestamp
    Show-Overlay -ProgressMax 5 -BatchTimestamp $BatchTimestamp

    # Process Each Row
    for ($RowIndex = 0; $RowIndex -lt $TotalRows; $RowIndex++) {
        $Row = $DataGridView.Rows[$RowIndex]
        $PDFFileName = $Row.Cells["Master PDF"].Value
        $OutputName = $Row.Cells["Output Name"].Value
        $PageRanges = $Row.Cells["Page Range"].Value
        $PDFPath = Join-Path $MasterPDFDir $PDFFileName
        $SaveDir = $BatchFolder

        if ([string]::IsNullOrWhiteSpace($PDFFileName) -or 
            [string]::IsNullOrWhiteSpace($OutputName) -or 
            [string]::IsNullOrWhiteSpace($PageRanges)) {
            Write-Host "‚ö† Skipping empty or incomplete row: ${RowIndex}"
            continue
        }

        if ($SkippedExports -contains "$OutputName.pdf") {
            continue
        }

        $Result = Print-PDF -PDFPath $PDFPath -PageRanges $PageRanges -SaveDir $SaveDir -OutputName $OutputName
        if ($Result -ne $null) {
            $FailedExports += $Result
        }
    }

    if ($FailedExports.Count -gt 0) {
        Close-AllEdgeProcesses
        Clear-PrintQueue
        Start-Sleep -Seconds 2
        Retry-FailedExports -FailedExports $FailedExports
    }

    Close-Overlay
    Move-ExportedFiles -BatchFolder $BatchFolder
    Stop-Logging

})  # ‚úÖ This closing brace was missing

# Ensure the script does not close until the GUI is properly closed
$Form.ShowDialog()
while ($Form.Visible) {
    Start-Sleep -Milliseconds 100
    [System.Windows.Forms.Application]::DoEvents()
}


